import bcrypt from "bcryptjs";
import { env } from "../src/config/env.js";
import { pool } from "../src/db/pool.js";

const seedAdminEmail = process.env.SEED_ADMIN_EMAIL ?? "admin@adfix.local";
const seedAdminName = process.env.SEED_ADMIN_NAME ?? "Adfix Admin";
const seedAdminPassword = process.env.SEED_ADMIN_PASSWORD ?? "ChangeMe123!";

function readSeedProfileArg() {
  const profileArg = process.argv.find((arg) => arg.startsWith("--profile="));
  if (!profileArg) return null;

  const value = profileArg.split("=")[1];
  return value === "demo" || value === "admin_only" ? value : null;
}

async function ensureAdminUser() {
  const passwordHash = await bcrypt.hash(seedAdminPassword, 12);

  await pool.query(
    `
    INSERT INTO users (email, name, password_hash, is_active)
    VALUES ($1, $2, $3, TRUE)
    ON CONFLICT (email)
    DO UPDATE
      SET name = EXCLUDED.name,
          password_hash = EXCLUDED.password_hash,
          is_active = TRUE,
          deleted_at = NULL,
          updated_at = NOW()
    `,
    [seedAdminEmail, seedAdminName, passwordHash]
  );

  console.log(`Seeded admin user: ${seedAdminEmail}`);
}

async function seedDemoData() {
  const adminUser = await pool.query<{ id: string }>(
    `SELECT id FROM users WHERE email = $1 AND deleted_at IS NULL`,
    [seedAdminEmail]
  );
  const adminId = adminUser.rows[0]?.id;
  if (!adminId) {
    throw new Error("Admin user was not found after seeding.");
  }

  const existingClient = await pool.query<{ id: string }>(
    `SELECT id FROM clients WHERE email = 'demo.client@adfix.local' AND deleted_at IS NULL LIMIT 1`
  );
  let clientId = existingClient.rows[0]?.id;
  if (!clientId) {
    const inserted = await pool.query<{ id: string }>(
      `
      INSERT INTO clients (name, company, email, notes)
      VALUES ('Demo Client', 'Adfix Demo Co', 'demo.client@adfix.local', 'Generated by demo seed profile')
      RETURNING id
      `
    );
    clientId = inserted.rows[0]?.id;
  }

  if (!clientId) {
    throw new Error("Failed to create or fetch demo client.");
  }

  const existingProject = await pool.query<{ id: string }>(
    `SELECT id FROM projects WHERE client_id = $1 AND name = 'Demo Project' AND deleted_at IS NULL LIMIT 1`,
    [clientId]
  );
  let projectId = existingProject.rows[0]?.id;
  if (!projectId) {
    const inserted = await pool.query<{ id: string }>(
      `
      INSERT INTO projects (
        client_id, name, description, current_phase, priority, start_date, deadline, created_by
      )
      VALUES (
        $1, 'Demo Project', 'Demo seeded project for local development', 'strategy_planning', 'high',
        CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', $2
      )
      RETURNING id
      `,
      [clientId, adminId]
    );
    projectId = inserted.rows[0]?.id;
  }

  if (!projectId) {
    throw new Error("Failed to create or fetch demo project.");
  }

  const existingTaskCount = await pool.query<{ count: string }>(
    `SELECT COUNT(*)::text AS count FROM tasks WHERE project_id = $1 AND deleted_at IS NULL`,
    [projectId]
  );

  if (Number(existingTaskCount.rows[0]?.count ?? 0) === 0) {
    await pool.query(
      `
      INSERT INTO tasks (project_id, title, description, phase, status, priority, created_by)
      VALUES
        ($1, 'Kickoff call', 'Initial stakeholder kickoff meeting', 'strategy_planning', 'completed', 'high', $2),
        ($1, 'Creative brief draft', 'Prepare first draft for internal review', 'strategy_planning', 'in_progress', 'high', $2),
        ($1, 'Content requirements', 'Collect assets and copy requirements', 'production', 'pending', 'medium', $2)
      `,
      [projectId, adminId]
    );
  }

  console.log("Seeded demo data profile");
}

async function run() {
  // Access env to fail fast if required config is missing.
  void env.DATABASE_URL;

  await ensureAdminUser();

  const profile = readSeedProfileArg() ?? env.SEED_PROFILE;
  if (profile === "demo") {
    await seedDemoData();
  }
}

run()
  .catch((error) => {
    console.error("Seeding failed:", error);
    process.exitCode = 1;
  })
  .finally(async () => {
    await pool.end();
  });
